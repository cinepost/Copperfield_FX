/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.3
 *
 * Copyright (c) 2016 Riverbank Computing Limited <info@riverbankcomputing.com>
 * 
 * This file is part of PyQt4.
 * 
 * This file may be used under the terms of the GNU General Public License
 * version 3.0 as published by the Free Software Foundation and appearing in
 * the file LICENSE included in the packaging of this file.  Please review the
 * following information to ensure the GNU General Public License version 3.0
 * requirements will be met: http://www.gnu.org/copyleft/gpl.html.
 * 
 * If you do not wish to use this file under the terms of the GPL version 3.0
 * then you may purchase a commercial license.  For more information contact
 * info@riverbankcomputing.com.
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "sipAPIQtCore.h"

#line 29 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
#include <qobject.h>
#line 29 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

#line 26 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 33 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 36 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 368 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 39 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 351 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 42 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 265 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 45 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 28 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qlist.sip"
#include <qlist.h>
#line 48 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 32 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 51 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 54 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 115 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qlist.sip"
#include <qlist.h>
#line 57 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qthread.sip"
#include <qthread.h>
#line 60 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 27 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qstring.sip"
#include <qstring.h>
#line 63 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 66 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
#line 33 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
// This is needed by the tr() and trUt8() handwritten implementations.
#include <qcoreapplication.h>


// These are the helper functions for QObject::findChild() and
// QObject::findChildren.

// Wrap the given type in a 1-tuple.
static PyObject *qtcore_type_to_tuple(PyObject *type)
{
    PyObject *tuple = PyTuple_New(1);

    if (tuple)
    {
        Py_INCREF(type);
        PyTuple_SET_ITEM(tuple, 0, type);
    }

    return tuple;
}


// Check all elements of a given tuple are type objects and return a new
// reference to the tuple if so.
static PyObject *qtcore_check_tuple_types(PyObject *types)
{
    for (SIP_SSIZE_T i = 0; i < PyTuple_GET_SIZE(types); ++i)
        if (!PyObject_TypeCheck(PyTuple_GET_ITEM(types, i), &PyType_Type))
        {
            PyErr_SetString(PyExc_TypeError,
                    "all elements of the types argument must be type objects");
            return 0;
        }

    Py_INCREF(types);
    return types;
}


// Do the main work of finding a child.
static PyObject *qtcore_do_find_child(const QObject *parent, PyObject *types, const QString &name)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return 0;

        if (name.isNull() || obj->objectName() == name)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    return pyo;

        Py_DECREF(pyo);
    }

    for (i = 0; i < children.size(); ++i)
    {
        PyObject *pyo = qtcore_do_find_child(children.at(i), types, name);

        if (pyo != Py_None)
            return pyo;

        Py_DECREF(pyo);
    }

    Py_INCREF(Py_None);
    return Py_None;
}


// Find a child that is one of a number of types and with an optional name.
static PyObject *qtcore_FindChild(const QObject *parent, PyObject *types, const QString &name)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *child = qtcore_do_find_child(parent, types, name);

    Py_DECREF(types);

    return child;
}


// Do the main work of finding the children with a string name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QString &name, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        if (name.isNull() || obj->objectName() == name)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        bool ok = qtcore_do_find_children(obj, types, name, list);

        if (!ok)
            return false;
    }

    return true;
}


// Find a child that is one of a number of types and with an optional string
// name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QString &name)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, name, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}


// Do the main work of finding the children with a regular expression name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegExp &re, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        if (re.indexIn(obj->objectName()) >= 0)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        bool ok = qtcore_do_find_children(obj, types, re, list);

        if (!ok)
            return false;
    }

    return true;
}


// Find a child that is one of a number of types and with an optional regular
// expression name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegExp &re)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, re, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}
#line 267 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"


class sipQObject : public  ::QObject
{
public:
    sipQObject( ::QObject*);
    virtual ~sipQObject();

    int qt_metacall(QMetaObject::Call,int,void **);
    void *qt_metacast(const char *);
    const QMetaObject *metaObject() const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const char*);
    void connectNotify(const char*);
    void customEvent( ::QEvent*);
    void childEvent( ::QChildEvent*);
    void timerEvent( ::QTimerEvent*);
    bool eventFilter( ::QObject*, ::QEvent*);
    bool event( ::QEvent*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQObject(const sipQObject &);
    sipQObject &operator = (const sipQObject &);

    char sipPyMethods[7];
};

sipQObject::sipQObject( ::QObject*a0):  ::QObject(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQObject::~sipQObject()
{
    sipInstanceDestroyed(sipPySelf);
}

const QMetaObject *sipQObject::metaObject() const
{
    return sip_QtCore_qt_metaobject(sipPySelf,sipType_QObject);
}

int sipQObject::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QObject::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtCore_qt_metacall(sipPySelf,sipType_QObject,_c,_id,_a);

    return _id;
}

void *sipQObject::qt_metacast(const char *_clname)
{
    return (sip_QtCore_qt_metacast(sipPySelf, sipType_QObject, _clname)) ? this :  ::QObject::qt_metacast(_clname);
}

void sipQObject::disconnectNotify(const char*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QObject::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtCore_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const char*);

    sipVH_QtCore_5(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipQObject::connectNotify(const char*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QObject::connectNotify(a0);
        return;
    }

    extern void sipVH_QtCore_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const char*);

    sipVH_QtCore_5(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipQObject::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_customEvent);

    if (!sipMeth)
    {
         ::QObject::customEvent(a0);
        return;
    }

    extern void sipVH_QtCore_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtCore_4(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipQObject::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_childEvent);

    if (!sipMeth)
    {
         ::QObject::childEvent(a0);
        return;
    }

    extern void sipVH_QtCore_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtCore_3(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipQObject::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QObject::timerEvent(a0);
        return;
    }

    extern void sipVH_QtCore_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtCore_2(sipGILState, 0, sipPySelf, sipMeth, a0);
}

bool sipQObject::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_eventFilter);

    if (!sipMeth)
        return  ::QObject::eventFilter(a0,a1);

    extern bool sipVH_QtCore_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtCore_1(sipGILState, 0, sipPySelf, sipMeth, a0, a1);
}

bool sipQObject::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_event);

    if (!sipMeth)
        return  ::QObject::event(a0);

    extern bool sipVH_QtCore_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtCore_0(sipGILState, 0, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QObject_metaObject, "metaObject(self) -> QMetaObject");

extern "C" {static PyObject *meth_QObject_metaObject(PyObject *, PyObject *);}
static PyObject *meth_QObject_metaObject(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            const  ::QMetaObject*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->metaObject();
            Py_END_ALLOW_THREADS

            return sipConvertFromType(const_cast< ::QMetaObject *>(sipRes),sipType_QMetaObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_metaObject, doc_QObject_metaObject);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_pyqtConfigure, "QObject.pyqtConfigure(**options)\n"
    "\n"
    "Each keyword argument is either the name of a Qt property or a Qt signal.\n"
    "For properties the property is set to the given value which should be of an\n"
    "appropriate type.\n"
    "For signals the signal is connected to the given value which should be a\n"
    "callable.");

extern "C" {static PyObject *meth_QObject_pyqtConfigure(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_pyqtConfigure(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
#line 417 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        return qpycore_pyqtconfigure(sipSelf, sipArgs, sipKwds);
#line 497 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
}


PyDoc_STRVAR(doc_QObject___getattr__, "__getattr__(self, str) -> object");

extern "C" {static PyObject *meth_QObject___getattr__(PyObject *, PyObject *);}
static PyObject *meth_QObject___getattr__(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            PyObject * sipRes = 0;

#line 422 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_getattr(const_cast<QObject *>(sipCpp), sipSelf, a0);
#line 519 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName___getattr__, doc_QObject___getattr__);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_event, "event(self, QEvent) -> bool");

extern "C" {static PyObject *meth_QObject_event(PyObject *, PyObject *);}
static PyObject *meth_QObject_event(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QEvent* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QEvent, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::QObject::event(a0) : sipCpp->event(a0));
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_event, doc_QObject_event);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_eventFilter, "eventFilter(self, QObject, QEvent) -> bool");

extern "C" {static PyObject *meth_QObject_eventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_eventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QObject* a0;
         ::QEvent* a1;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0, sipType_QEvent, &a1))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::QObject::eventFilter(a0,a1) : sipCpp->eventFilter(a0,a1));
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_eventFilter, doc_QObject_eventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_tr, "tr(self, str, disambiguation: str = None, n: int = -1) -> str");

extern "C" {static PyObject *meth_QObject_tr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_tr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const char* a1 = 0;
        int a2 = -1;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_disambiguation,
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BP0|si", &sipSelf, sipType_QObject, &sipCpp, &a0, &a1, &a2))
        {
             ::QString*sipRes = 0;
            int sipIsErr = 0;

#line 440 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::CodecForTr);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::CodecForTr, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
#line 638 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_tr, doc_QObject_tr);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_trUtf8, "trUtf8(self, str, disambiguation: str = None, n: int = -1) -> str");

extern "C" {static PyObject *meth_QObject_trUtf8(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_trUtf8(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const char* a1 = 0;
        int a2 = -1;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_disambiguation,
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BP0|si", &sipSelf, sipType_QObject, &sipCpp, &a0, &a1, &a2))
        {
             ::QString*sipRes = 0;
            int sipIsErr = 0;

#line 499 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::UnicodeUTF8);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::UnicodeUTF8, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
#line 695 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_trUtf8, doc_QObject_trUtf8);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_findChild, "findChild(self, type, name: str = '') -> QObject\n"
    "findChild(self, Tuple, name: str = '') -> QObject");

extern "C" {static PyObject *meth_QObject_findChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_findChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QString,&a1, &a1State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 557 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChild(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 743 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QString,&a1, &a1State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 565 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChild(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 775 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_findChild, doc_QObject_findChild);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_findChildren, "findChildren(self, type, name: str = '') -> List[QObject]\n"
    "findChildren(self, Tuple, name: str = '') -> List[QObject]\n"
    "findChildren(self, type, QRegExp) -> List[QObject]\n"
    "findChildren(self, Tuple, QRegExp) -> List[QObject]");

extern "C" {static PyObject *meth_QObject_findChildren(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_findChildren(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QString,&a1, &a1State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 573 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 828 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QString,&a1, &a1State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 581 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 860 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QRegExp* a1;
        const  ::QObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BTJ9", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QRegExp, &a1))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 589 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 885 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QRegExp* a1;
        const  ::QObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BTJ9", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QRegExp, &a1))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 597 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 909 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_findChildren, doc_QObject_findChildren);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_emit, "emit(self, QT_SIGNAL, *)");

extern "C" {static PyObject *meth_QObject_emit(PyObject *, PyObject *);}
static PyObject *meth_QObject_emit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        PyObject * a1;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BP0W", &sipSelf, sipType_QObject, &sipCpp, &a0, &a1))
        {
            sipErrorState sipError = sipErrorNone;

#line 605 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipError = qpycore_qobject_emit(sipCpp, a0, a1);
#line 944 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            Py_DECREF(a1);

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            Py_INCREF(Py_None);
            return Py_None;
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_emit, doc_QObject_emit);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_objectName, "objectName(self) -> str");

extern "C" {static PyObject *meth_QObject_objectName(PyObject *, PyObject *);}
static PyObject *meth_QObject_objectName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::QString(sipCpp->objectName());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_objectName, doc_QObject_objectName);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setObjectName, "setObjectName(self, str)");

extern "C" {static PyObject *meth_QObject_setObjectName(PyObject *, PyObject *);}
static PyObject *meth_QObject_setObjectName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QObject, &sipCpp, sipType_QString,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setObjectName(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setObjectName, doc_QObject_setObjectName);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_isWidgetType, "isWidgetType(self) -> bool");

extern "C" {static PyObject *meth_QObject_isWidgetType(PyObject *, PyObject *);}
static PyObject *meth_QObject_isWidgetType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->isWidgetType();
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_isWidgetType, doc_QObject_isWidgetType);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_signalsBlocked, "signalsBlocked(self) -> bool");

extern "C" {static PyObject *meth_QObject_signalsBlocked(PyObject *, PyObject *);}
static PyObject *meth_QObject_signalsBlocked(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->signalsBlocked();
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_signalsBlocked, doc_QObject_signalsBlocked);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_blockSignals, "blockSignals(self, bool) -> bool");

extern "C" {static PyObject *meth_QObject_blockSignals(PyObject *, PyObject *);}
static PyObject *meth_QObject_blockSignals(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->blockSignals(a0);
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_blockSignals, doc_QObject_blockSignals);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_thread, "thread(self) -> QThread");

extern "C" {static PyObject *meth_QObject_thread(PyObject *, PyObject *);}
static PyObject *meth_QObject_thread(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QThread*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->thread();
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QThread,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_thread, doc_QObject_thread);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_moveToThread, "moveToThread(self, QThread)");

extern "C" {static PyObject *meth_QObject_moveToThread(PyObject *, PyObject *);}
static PyObject *meth_QObject_moveToThread(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QThread* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QThread, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->moveToThread(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_moveToThread, doc_QObject_moveToThread);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_startTimer, "startTimer(self, int) -> int");

extern "C" {static PyObject *meth_QObject_startTimer(PyObject *, PyObject *);}
static PyObject *meth_QObject_startTimer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->startTimer(a0);
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_startTimer, doc_QObject_startTimer);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_killTimer, "killTimer(self, int)");

extern "C" {static PyObject *meth_QObject_killTimer(PyObject *, PyObject *);}
static PyObject *meth_QObject_killTimer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->killTimer(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_killTimer, doc_QObject_killTimer);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_children, "children(self) -> object");

extern "C" {static PyObject *meth_QObject_children(PyObject *, PyObject *);}
static PyObject *meth_QObject_children(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QObjectList*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::QObjectList(sipCpp->children());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0101QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_children, doc_QObject_children);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setParent, "setParent(self, QObject)");

extern "C" {static PyObject *meth_QObject_setParent(PyObject *, PyObject *);}
static PyObject *meth_QObject_setParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject* a0;
        sipWrapper *sipOwner = 0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJH", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0, &sipOwner))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setParent(a0);
            Py_END_ALLOW_THREADS

            if (sipOwner)
                sipTransferTo(sipSelf, (PyObject *)sipOwner);
            else
                sipTransferBack(sipSelf);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setParent, doc_QObject_setParent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_installEventFilter, "installEventFilter(self, QObject)");

extern "C" {static PyObject *meth_QObject_installEventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_installEventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->installEventFilter(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_installEventFilter, doc_QObject_installEventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_removeEventFilter, "removeEventFilter(self, QObject)");

extern "C" {static PyObject *meth_QObject_removeEventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_removeEventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->removeEventFilter(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_removeEventFilter, doc_QObject_removeEventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_connect, "connect(QObject, QT_SIGNAL, QObject, QT_SLOT, Qt.ConnectionType = Qt.AutoConnection) -> bool\n"
    "connect(QObject, QT_SIGNAL, Callable[..., None], Qt.ConnectionType = Qt.AutoConnection) -> bool\n"
    "connect(self, QObject, QT_SIGNAL, QT_SLOT, Qt.ConnectionType = Qt.AutoConnection) -> bool");

extern "C" {static PyObject *meth_QObject_connect(PyObject *, PyObject *);}
static PyObject *meth_QObject_connect(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject* a0;
        PyObject *a0Wrapper;
        PyObject * a1;
        PyObject * a2;
        PyObject * a3;
         ::Qt::ConnectionType a4 = Qt::AutoConnection;

        if (sipParseArgs(&sipParseErr, sipArgs, "@J8P0P0P0|E", &a0Wrapper, sipType_QObject, &a0, &a1, &a2, &a3, sipType_Qt_ConnectionType, &a4))
        {
            PyObject * sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 631 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_connect(&sipError, a0, a0Wrapper, a1, a2, a3, (int)a4);
#line 1395 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return sipRes;
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    {
         ::QObject* a0;
        PyObject *a0Wrapper;
        PyObject * a1;
        PyObject * a2;
         ::Qt::ConnectionType a3 = Qt::AutoConnection;

        if (sipParseArgs(&sipParseErr, sipArgs, "@J8P0F|E", &a0Wrapper, sipType_QObject, &a0, &a1, &a2, sipType_Qt_ConnectionType, &a3))
        {
            PyObject * sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 636 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_connect(&sipError, a0, a0Wrapper, a1, a2, 0, (int)a3);
#line 1423 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return sipRes;
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    {
         ::QObject* a0;
        PyObject *a0Wrapper;
        PyObject * a1;
        PyObject * a2;
         ::Qt::ConnectionType a3 = Qt::AutoConnection;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B@J8P0P0|E", &sipSelf, sipType_QObject, &sipCpp, &a0Wrapper, sipType_QObject, &a0, &a1, &a2, sipType_Qt_ConnectionType, &a3))
        {
            PyObject * sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 641 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_connect(&sipError, a0, a0Wrapper, a1, sipSelf, a2, (int)a3);
#line 1452 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return sipRes;
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_connect, doc_QObject_connect);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_disconnect, "disconnect(QObject, QT_SIGNAL, QObject, QT_SLOT) -> bool\n"
    "disconnect(QObject, QT_SIGNAL, Callable[..., None]) -> bool");

extern "C" {static PyObject *meth_QObject_disconnect(PyObject *, PyObject *);}
static PyObject *meth_QObject_disconnect(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject* a0;
        PyObject * a1;
        PyObject * a2;
        PyObject * a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8P0P0P0", sipType_QObject, &a0, &a1, &a2, &a3))
        {
            PyObject * sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 646 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_disconnect(&sipError, a0, a1, a2, a3);
#line 1496 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return sipRes;
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    {
         ::QObject* a0;
        PyObject * a1;
        PyObject * a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J8P0F", sipType_QObject, &a0, &a1, &a2))
        {
            PyObject * sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 651 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_disconnect(&sipError, a0, a1, a2, 0);
#line 1522 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return sipRes;
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_disconnect, doc_QObject_disconnect);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dumpObjectInfo, "dumpObjectInfo(self)");

extern "C" {static PyObject *meth_QObject_dumpObjectInfo(PyObject *, PyObject *);}
static PyObject *meth_QObject_dumpObjectInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->dumpObjectInfo();
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dumpObjectInfo, doc_QObject_dumpObjectInfo);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dumpObjectTree, "dumpObjectTree(self)");

extern "C" {static PyObject *meth_QObject_dumpObjectTree(PyObject *, PyObject *);}
static PyObject *meth_QObject_dumpObjectTree(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->dumpObjectTree();
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dumpObjectTree, doc_QObject_dumpObjectTree);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dynamicPropertyNames, "dynamicPropertyNames(self) -> object");

extern "C" {static PyObject *meth_QObject_dynamicPropertyNames(PyObject *, PyObject *);}
static PyObject *meth_QObject_dynamicPropertyNames(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QList< ::QByteArray>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new QList< ::QByteArray>(sipCpp->dynamicPropertyNames());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dynamicPropertyNames, doc_QObject_dynamicPropertyNames);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setProperty, "setProperty(self, str, Any) -> bool");

extern "C" {static PyObject *meth_QObject_setProperty(PyObject *, PyObject *);}
static PyObject *meth_QObject_setProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const  ::QVariant* a1;
        int a1State = 0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BsJ1", &sipSelf, sipType_QObject, &sipCpp, &a0, sipType_QVariant,&a1, &a1State))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->setProperty(a0,*a1);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QVariant *>(a1),sipType_QVariant,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setProperty, doc_QObject_setProperty);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_property, "property(self, str) -> Any");

extern "C" {static PyObject *meth_QObject_property(PyObject *, PyObject *);}
static PyObject *meth_QObject_property(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
             ::QVariant*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::QVariant(sipCpp->property(a0));
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_property, doc_QObject_property);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_parent, "parent(self) -> QObject");

extern "C" {static PyObject *meth_QObject_parent(PyObject *, PyObject *);}
static PyObject *meth_QObject_parent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QObject*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->parent();
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_parent, doc_QObject_parent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_inherits, "inherits(self, str) -> bool");

extern "C" {static PyObject *meth_QObject_inherits(PyObject *, PyObject *);}
static PyObject *meth_QObject_inherits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->inherits(a0);
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_inherits, doc_QObject_inherits);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_deleteLater, "deleteLater(self)");

extern "C" {static PyObject *meth_QObject_deleteLater(PyObject *, PyObject *);}
static PyObject *meth_QObject_deleteLater(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->deleteLater();
            Py_END_ALLOW_THREADS

            sipTransferTo(sipSelf, NULL);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_deleteLater, doc_QObject_deleteLater);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_sender, "sender(self) -> QObject");

extern "C" {static PyObject *meth_QObject_sender(PyObject *, PyObject *);}
static PyObject *meth_QObject_sender(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "p", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QObject*sipRes = 0;

#line 678 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        typedef QObject *(*helper_func)(QObject *);
        
        static helper_func helper = 0;
        
        if (!helper)
        {
            helper = (helper_func)sipImportSymbol("qpycore_qobject_sender");
            Q_ASSERT(helper);
        }
        
        // sender() must be called without the GIL to avoid possible deadlocks between
        // the GIL and Qt's internal thread data mutex.
        
        Py_BEGIN_ALLOW_THREADS
        
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        sipRes = sipCpp->sender();
        #else
        sipRes = sipCpp->sipProtect_sender();
        #endif
        
        Py_END_ALLOW_THREADS
        
        sipRes = helper(sipRes);
#line 1828 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_sender, doc_QObject_sender);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_receivers, "receivers(self, QT_SIGNAL) -> int");

extern "C" {static PyObject *meth_QObject_receivers(PyObject *, PyObject *);}
static PyObject *meth_QObject_receivers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pP0", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            int sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 706 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        // We need to take into account any proxies for Python signals. Import the
        // helpers if it hasn't already been done.
        typedef const char *(*pyqt4_get_signal_t)(PyObject *);
        typedef int (*receivers_helper_func)(QObject *, const char *, int);
        
        static pyqt4_get_signal_t pyqt4_get_signal = 0;
        static receivers_helper_func receivers_helper = 0;
        
        if (!pyqt4_get_signal)
        {
            pyqt4_get_signal = (pyqt4_get_signal_t)sipImportSymbol("pyqt4_get_signal");
            Q_ASSERT(pyqt4_get_signal);
        }
        
        if (!receivers_helper)
        {
            receivers_helper = (receivers_helper_func)sipImportSymbol("qpycore_qobject_receivers");
            Q_ASSERT(receivers_helper);
        }
        
        // PyQt5: Get rid of the const casts.
        const char *sig = pyqt4_get_signal(a0);
            
        if (sig)
        {
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            sipRes = receivers_helper(const_cast<QObject *>(sipCpp), sig, sipCpp->receivers(sig));
        #else
            sipRes = receivers_helper(const_cast<QObject *>(static_cast<const QObject *>(sipCpp)), sig, sipCpp->sipProtect_receivers(sig));
        #endif
        }
        else
        {
            sipError = sipBadCallableArg(0, a0);
        }
#line 1894 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return SIPLong_FromLong(sipRes);
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_receivers, doc_QObject_receivers);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_timerEvent, "timerEvent(self, QTimerEvent)");

extern "C" {static PyObject *meth_QObject_timerEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_timerEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QTimerEvent* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QTimerEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::QObject::timerEvent(a0) : sipCpp->timerEvent(a0));
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_timerEvent, doc_QObject_timerEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_childEvent, "childEvent(self, QChildEvent)");

extern "C" {static PyObject *meth_QObject_childEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_childEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QChildEvent* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QChildEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::QObject::childEvent(a0) : sipCpp->childEvent(a0));
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_childEvent, doc_QObject_childEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_customEvent, "customEvent(self, QEvent)");

extern "C" {static PyObject *meth_QObject_customEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_customEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QEvent* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::QObject::customEvent(a0) : sipCpp->customEvent(a0));
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_customEvent, doc_QObject_customEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_connectNotify, "connectNotify(self, QT_SIGNAL)");

extern "C" {static PyObject *meth_QObject_connectNotify(PyObject *, PyObject *);}
static PyObject *meth_QObject_connectNotify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        PyObject * a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pP0", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            sipErrorState sipError = sipErrorNone;

#line 752 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        typedef const char *(*pyqt4_get_signal_t)(PyObject *);
        
        static pyqt4_get_signal_t pyqt4_get_signal = 0;
        
        if (!pyqt4_get_signal)
        {
            pyqt4_get_signal = (pyqt4_get_signal_t)sipImportSymbol("pyqt4_get_signal");
            Q_ASSERT(pyqt4_get_signal);
        }
        
        const char *sig = pyqt4_get_signal(a0);
            
        if (sig)
        {
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            (sipSelfWasArg ? sipCpp->QObject::connectNotify(sig) : sipCpp->connectNotify(sig));
        #else
            sipCpp->sipProtectVirt_connectNotify(sipSelfWasArg, sig);
        #endif
        }
        else
        {
            sipError = sipBadCallableArg(0, a0);
        }
#line 2050 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            Py_INCREF(Py_None);
            return Py_None;
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_connectNotify, doc_QObject_connectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_disconnectNotify, "disconnectNotify(self, QT_SIGNAL)");

extern "C" {static PyObject *meth_QObject_disconnectNotify(PyObject *, PyObject *);}
static PyObject *meth_QObject_disconnectNotify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        PyObject * a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pP0", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            sipErrorState sipError = sipErrorNone;

#line 785 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        typedef const char *(*pyqt4_get_signal_t)(PyObject *);
        
        static pyqt4_get_signal_t pyqt4_get_signal = 0;
        
        if (!pyqt4_get_signal)
        {
            pyqt4_get_signal = (pyqt4_get_signal_t)sipImportSymbol("pyqt4_get_signal");
            Q_ASSERT(pyqt4_get_signal);
        }
        
        const char *sig = pyqt4_get_signal(a0);
            
        if (sig)
        {
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            (sipSelfWasArg ? sipCpp->QObject::disconnectNotify(sig) : sipCpp->disconnectNotify(sig));
        #else
            sipCpp->sipProtectVirt_disconnectNotify(sipSelfWasArg, sig);
        #endif
        }
        else
        {
            sipError = sipBadCallableArg(0, a0);
        }
#line 2114 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            Py_INCREF(Py_None);
            return Py_None;
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_disconnectNotify, doc_QObject_disconnectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_senderSignalIndex, "senderSignalIndex(self) -> int");

extern "C" {static PyObject *meth_QObject_senderSignalIndex(PyObject *, PyObject *);}
static PyObject *meth_QObject_senderSignalIndex(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "p", &sipSelf, sipType_QObject, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->senderSignalIndex();
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_senderSignalIndex, doc_QObject_senderSignalIndex);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QObject(void *, int);}
static void release_QObject(void *sipCppV, int)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(sipCppV);

    Py_BEGIN_ALLOW_THREADS

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();

    Py_END_ALLOW_THREADS
}


extern "C" {static int traverse_QObject(void *, visitproc, void *);}
static int traverse_QObject(void *sipCppV,visitproc sipVisit,void *sipArg)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(sipCppV);
    int sipRes;

#line 386 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
    // Traverse any saved slots we might be connected to.
    sipRes = qpycore_visitSlotProxies(sipCpp, sipVisit, sipArg);
#line 2192 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

    return sipRes;
}


extern "C" {static int clear_QObject(void *);}
static int clear_QObject(void *sipCppV)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(sipCppV);
    int sipRes;

#line 391 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
    // Clear any saved slots we might be connected to.
    sipRes = qpycore_clearSlotProxies(sipCpp);
#line 2207 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

    return sipRes;
}


extern "C" {static int final_QObject(PyObject *, void *, PyObject *, PyObject **);}
static int final_QObject(PyObject *sipSelf, void *sipCppV, PyObject *sipKwds, PyObject **sipUnused)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(sipCppV);

#line 235 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
    return qpycore_qobject_finalisation(sipSelf, sipCpp, sipKwds, sipUnused);
#line 2220 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"
}


extern "C" {static void dealloc_QObject(sipSimpleWrapper *);}
static void dealloc_QObject(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQObject *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QObject(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QObject(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QObject(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQObject *sipCpp = 0;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipQObject(a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QObject[] = {
    {SIP_MLNAME_CAST(sipName___getattr__), meth_QObject___getattr__, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject___getattr__)},
    {SIP_MLNAME_CAST(sipName_blockSignals), meth_QObject_blockSignals, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_blockSignals)},
    {SIP_MLNAME_CAST(sipName_childEvent), meth_QObject_childEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_childEvent)},
    {SIP_MLNAME_CAST(sipName_children), meth_QObject_children, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_children)},
    {SIP_MLNAME_CAST(sipName_connect), meth_QObject_connect, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_connect)},
    {SIP_MLNAME_CAST(sipName_connectNotify), meth_QObject_connectNotify, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_connectNotify)},
    {SIP_MLNAME_CAST(sipName_customEvent), meth_QObject_customEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_customEvent)},
    {SIP_MLNAME_CAST(sipName_deleteLater), meth_QObject_deleteLater, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_deleteLater)},
    {SIP_MLNAME_CAST(sipName_disconnect), meth_QObject_disconnect, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_disconnect)},
    {SIP_MLNAME_CAST(sipName_disconnectNotify), meth_QObject_disconnectNotify, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_disconnectNotify)},
    {SIP_MLNAME_CAST(sipName_dumpObjectInfo), meth_QObject_dumpObjectInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dumpObjectInfo)},
    {SIP_MLNAME_CAST(sipName_dumpObjectTree), meth_QObject_dumpObjectTree, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dumpObjectTree)},
    {SIP_MLNAME_CAST(sipName_dynamicPropertyNames), meth_QObject_dynamicPropertyNames, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dynamicPropertyNames)},
    {SIP_MLNAME_CAST(sipName_emit), meth_QObject_emit, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_emit)},
    {SIP_MLNAME_CAST(sipName_event), meth_QObject_event, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_event)},
    {SIP_MLNAME_CAST(sipName_eventFilter), meth_QObject_eventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_eventFilter)},
    {SIP_MLNAME_CAST(sipName_findChild), (PyCFunction)meth_QObject_findChild, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_findChild)},
    {SIP_MLNAME_CAST(sipName_findChildren), (PyCFunction)meth_QObject_findChildren, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_findChildren)},
    {SIP_MLNAME_CAST(sipName_inherits), meth_QObject_inherits, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_inherits)},
    {SIP_MLNAME_CAST(sipName_installEventFilter), meth_QObject_installEventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_installEventFilter)},
    {SIP_MLNAME_CAST(sipName_isWidgetType), meth_QObject_isWidgetType, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_isWidgetType)},
    {SIP_MLNAME_CAST(sipName_killTimer), meth_QObject_killTimer, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_killTimer)},
    {SIP_MLNAME_CAST(sipName_metaObject), meth_QObject_metaObject, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_metaObject)},
    {SIP_MLNAME_CAST(sipName_moveToThread), meth_QObject_moveToThread, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_moveToThread)},
    {SIP_MLNAME_CAST(sipName_objectName), meth_QObject_objectName, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_objectName)},
    {SIP_MLNAME_CAST(sipName_parent), meth_QObject_parent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_parent)},
    {SIP_MLNAME_CAST(sipName_property), meth_QObject_property, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_property)},
    {SIP_MLNAME_CAST(sipName_pyqtConfigure), (PyCFunction)meth_QObject_pyqtConfigure, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_pyqtConfigure)},
    {SIP_MLNAME_CAST(sipName_receivers), meth_QObject_receivers, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_receivers)},
    {SIP_MLNAME_CAST(sipName_removeEventFilter), meth_QObject_removeEventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_removeEventFilter)},
    {SIP_MLNAME_CAST(sipName_sender), meth_QObject_sender, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_sender)},
    {SIP_MLNAME_CAST(sipName_senderSignalIndex), meth_QObject_senderSignalIndex, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_senderSignalIndex)},
    {SIP_MLNAME_CAST(sipName_setObjectName), meth_QObject_setObjectName, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setObjectName)},
    {SIP_MLNAME_CAST(sipName_setParent), meth_QObject_setParent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setParent)},
    {SIP_MLNAME_CAST(sipName_setProperty), meth_QObject_setProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setProperty)},
    {SIP_MLNAME_CAST(sipName_signalsBlocked), meth_QObject_signalsBlocked, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_signalsBlocked)},
    {SIP_MLNAME_CAST(sipName_startTimer), meth_QObject_startTimer, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_startTimer)},
    {SIP_MLNAME_CAST(sipName_thread), meth_QObject_thread, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_thread)},
    {SIP_MLNAME_CAST(sipName_timerEvent), meth_QObject_timerEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_timerEvent)},
    {SIP_MLNAME_CAST(sipName_tr), (PyCFunction)meth_QObject_tr, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_tr)},
    {SIP_MLNAME_CAST(sipName_trUtf8), (PyCFunction)meth_QObject_trUtf8, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_trUtf8)}
};


extern "C" {static PyObject *varget_QObject_staticMetaObject(void *, PyObject *, PyObject *);}
static PyObject *varget_QObject_staticMetaObject(void *, PyObject *, PyObject *sipPyType)
{
    PyObject *sipPy;

#line 398 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/sip/QtCore/qobject.sip"
        sipPy = qpycore_qobject_staticmetaobject(sipPyType);
#line 2317 "/Users/max/dev/Copperfield_FX/tmp/PyQt4_gpl_mac-4.12.1/QtCore/sipQtCoreQObject.cpp"

    return sipPy;
}

sipVariableDef variables_QObject[] = {
    {ClassVariable, sipName_staticMetaObject, (PyMethodDef *)varget_QObject_staticMetaObject, NULL, NULL, NULL},
};

PyDoc_STRVAR(doc_QObject, "\1QObject(parent: QObject = None)");


/* Define this type's signals. */
static const pyqt4QtSignal signals_QObject[] = {
    {"destroyed(QObject*)", "\1destroyed(self, QObject = None)", 0, 1},
    {"destroyed()", "\1destroyed(self)", 0, 1},
    {0, 0, 0, 0}
};


static pyqt4ClassPluginDef plugin_QObject = {
    & ::QObject::staticMetaObject,
    0,
    signals_QObject
};


sipClassTypeDef sipTypeDef_QtCore_QObject = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_NONLAZY|SIP_TYPE_CLASS,
        sipNameNr_QObject,
        {0},
        &plugin_QObject
    },
    {
        sipNameNr_QObject,
        {0, 0, 1},
        41, methods_QObject,
        0, 0,
        1, variables_QObject,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QObject,
    sipNameNr_PyQt4_QtCore_pyqtWrapperType,
    -1,
    0,
    0,
    init_type_QObject,
    traverse_QObject,
    clear_QObject,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QObject,
    0,
    0,
    0,
    release_QObject,
    0,
    0,
    0,
    0,
    0,
    final_QObject,
    0
};
